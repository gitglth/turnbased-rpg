<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprController</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//czcionka = font_add('Arial',20,false,false,32,128);

afterLoad = false;
alarm[11] = 10;
sprite_index = sprBlank;
//show_debug_overlay(true);

hour = 12;
minute = 0;
sunlight = -0.5*(cos(degtorad((hour + 0.0167 * minute)*15))-1);
sunx = (sin(degtorad((hour + 0.0167 * minute)*15)));
suny = (cos(degtorad((hour + 0.0167 * minute)*15)));
overcastfinal = 0;
overcast = overcastfinal;
alarm[1] = room_speed * 10;

randomize();
cloud[0, 0] = irandom(1280);
cloud[0, 1] = irandom(720);
cloud[0, 2] = irandom(4);
cloud[0, 3] = 1 + random(1);
cloud[0, 4] = 1 + random(1);
cloud[1, 0] = irandom(1280);
cloud[1, 1] = irandom(720);
cloud[1, 2] = irandom(4);
cloud[1, 3] = 1 + random(1);
cloud[1, 4] = 1 + random(1);
cloud[2, 0] = irandom(1280);
cloud[2, 1] = irandom(720);
cloud[2, 2] = irandom(4);
cloud[2, 3] = 1 + random(1);
cloud[2, 4] = 1 + random(1);

attsurf = surface_create(1600,1600);
green = make_colour_rgb(128,255,0);
actionid = 0;
showfps = round(fps_real);
alarm[0] = room_speed/2;
sprite_index = sprBlank;
apcost = 0;
mode = 0;
turn = 0;
angle = 0;
battlequeue[] = 0;
firstturn = true;
onHud = false;
show_loot = false;
characters_inbattle = 0;
dotdist = 0;
currentChar = Hero.id;
nextturn = false;
smoothing = false;
ctrl_frame = false;
hexcenter_x = x;
hexcenter_y = y;
hexmade = false;
hexcomplete = false;
grid_snap = false;
pathFound = true;

alarm[2] = room_speed + irandom(room_speed * 7);

grass_density = 0;
grass_sway = true;

if(smoothing) texture_set_interpolation(true);
else texture_set_interpolation(false);
//display_reset(0, true);

i = 16;
instance_create(x, y, Camera);
instance_create(x, y, ShadowShader);
instance_create(x, y, LightShader);
instance_create(x, y, ActionCtrl);
instance_create(x, y, MarkerMask);
instance_create(x, y, InvCtrl);
instance_create(x, y, WaterShader);

for(i = 0; i &lt; 4; i++)
{
    for(j = 0; j &lt; 10; j++)
    {
        cooldown[i, j] = 0;
    }
}

/*for(g = 0; g &lt;= room_height; g += 16)
{
    instance_create(-24, g, GrassDrawer);
}*/

for(i = 0; i &lt; 6; i++)
{
    dirwheelmouseover[i] = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>afterLoad = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>border = irandom(3);

switch(border)
{
    case 0:
        instance_create(view_xview + view_wview + 120, view_yview + irandom(view_hview) , BirdShadow);
        break;
    case 1:
        instance_create(view_xview + irandom(view_wview), view_yview - 120 , BirdShadow);
        break;
    case 2:
        instance_create(view_xview - 120, view_yview + irandom(view_hview) , BirdShadow);
        break;
    case 3:
        instance_create(view_xview + irandom(view_wview), view_yview + view_hview + 120 , BirdShadow);
        break;
}

alarm[2] = room_speed + irandom(room_speed * 7);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>minute++;
if(minute &gt;= 60)
{
    hour++;
    if(hour&gt;=24) hour -= 24;
    minute -= 60;
}

sunlight = -0.5*(cos(degtorad((hour + 0.0167 * minute)*15))-1);
sunx = (sin(degtorad((hour + 0.0167 * minute)*15)));
suny = (cos(degtorad((hour + 0.0167 * minute)*15)));

//alarm[1] = 1;
alarm[1] = room_speed * 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>showfps = round(fps_real);

alarm[0] = room_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>x = view_xview;
y = view_yview;
depth = -y-10000;

if(afterLoad)
{
    instance_activate_all();
    x = Camera.x;
    y = Camera.y;
    ShadowShader.x = x;
    ShadowShader.y = y;
    LightShader.x = x;
    LightShader.y = y;
    WaterShader.x = x;
    WaterShader.y = y;
    ActionCtrl.x = x;
    ActionCtrl.y = y;
    InvCtrl.x = x;
    InvCtrl.y = y;
    
    /*with(EnemySpawner)
    {
        x_prev = x;
        y_prev = y;
        x = Ctrl.x;
        y = Ctrl.y;
    }*/
    
    instance_deactivate_region(view_xview - 800, view_yview - 400, view_wview + 1600, view_hview + 800, false, true);
    
    /*with(EnemySpawner)
    {
        x = x_prev;
        y = y_prev;
    }*/
    
    //instance_activate_object(ShadowShader);
    //instance_activate_object(LightShader);
    //instance_activate_object(WaterShader);
    //instance_activate_object(ActionCtrl);
    instance_activate_object(Camera);
    instance_activate_object(Hero);
    instance_activate_object(MarkerMask);
    //instance_activate_object(InvCtrl);
    instance_activate_object(DirWheel);
    instance_activate_object(EnemySpawner);
}

for(h = 0; h &lt; instance_number(Hero) ; h++)
{
    current = instance_find(Hero,h);
    if(current.number == 1) h1 = current;
    else if(current.number == 2) h2 = current;
    else if(current.number == 3) h3 = current;
    else if(current.number == 4) h4 = current;
}

if(mode == 0 &amp;&amp; InvCtrl.show_inv)
{
    if(mouse_x &gt;= view_xview + view_wview / 2 - 278 &amp;&amp; mouse_x &lt;= view_xview + view_wview /2 + 278 &amp;&amp; mouse_y &gt;= view_yview + view_hview - 216 - 32 &amp;&amp; mouse_y &lt;= view_yview + view_hview - 32) onHud = true;
    else if(InvCtrl.grabbed_item[1] != -1) onHud = true;
    else onHud = false;
}

if(mode == 1)
{
    if((currentChar).hp &lt;= 0) nextturn = true;

    if(!instance_exists(DirWheel))
    {
        for(i = 0; i &lt; 6; i++)
        {
            w = instance_create(view_xview + view_wview / 2, view_hview - 112, DirWheel);
            w.dir = i*60;
            w.image_index = i;
        }
    }

    if(h1.myturn == turn || h2.myturn == turn || h3.myturn == turn || h4.myturn == turn)
    {
        heroesturn = true;
        if(h1.myturn == turn)
        {
            hero = h1;
            InvCtrl.current_eq = 0;
        }
        else if(h2.myturn == turn)
        {
            hero = h2;
            InvCtrl.current_eq = 1;
        }
        else if(h3.myturn == turn)
        {
            hero = h3;
            InvCtrl.current_eq = 2;
        }
        else if(h4.myturn == turn)
        {
            hero = h4;
            InvCtrl.current_eq = 3;
        }
    }
    else heroesturn = false;
    
    dotdist++;
    if(dotdist &gt;= 64) dotdist = 0;
    
    if(instance_number(Hex) == 0)
    {
        instance_create(hexcenter_x,hexcenter_y,Hex);
        marker = Hex;
        oldmarker = marker;
    }
    
    if(heroesturn &amp;&amp; hexcomplete &amp;&amp; (currentChar).speed == 0 &amp;&amp; !instance_exists(MoveMarker) &amp;&amp; actionid == 0)
    {
        if(oldmarker != marker)
        {
            with(Hex)
            {
                pathDistance = -1;
                pathParent = -1;
                pathMoveMark = false;
            }
            
            pathFound = false;
            gotoHex = instance_position(mouse_x, mouse_y, Hex);
            if(gotoHex)
            {
                if(!gotoHex.occupied)
                {
                    h = instance_position((currentChar).x, (currentChar).y, Hex);
                    if(h)
                    {
                        h.pathDistance = 0;
                        z = 0;
                        pathDist = 1;
                        path_check_around(h);
                        
                        while(!pathFound || z &lt; 400)
                        {
                            for(i = 0; i &lt; instance_number(Hex); i++)
                            {
                                a = instance_find(Hex, i);
                                
                                if(a.pathDistance == pathDist)
                                {
                                    if(a == gotoHex)
                                    {
                                        pathFound = true;
                                    }
                                    else
                                    {
                                        path_check_around(a);
                                    }
                                }
                                
                            }
                            pathDist++;
                            z++;
                        }
                        if(pathFound)
                        {
                            gotoHex.pathMoveMark = true;
                            path_check_parent(gotoHex);
                        }
                    }
                }
            }
        }
        oldmarker = marker;
        
        if(pathFound == 1) 
        {
            apcost = gotoHex.pathDistance * 20;
        }
    }
    
    if(hexcomplete &amp;&amp; !grid_snap)
    {
        with(BattleParent)
        {
            if(battle == true)
            {
                n = 1;
                nearest_hex = instance_nearest2(x,y,Hex,n);
                
                while(nearest_hex.occupied == true)
                {
                    n++;
                    nearest_hex = instance_nearest2(x,y,Hex,n);
                }
                
                nearest_hex.occupied = true;
                x = nearest_hex.x;
                y = nearest_hex.y;
                direction = point_direction(xprevious, yprevious, x, y);
            }
        }
        hexcomplete = false;
        grid_snap = true;
    }
    
    if(firstturn)
    {
        turn=0;
        
        for(i = 0; i &lt; 4; i++)
        {
            for(j = 0; j &lt; 10; j++)
            {
                cooldown[i, j] = 0;
            }
        }
        
        for(h=0;h&lt;instance_number(Hero);h++)
        {
            current = instance_find(Hero,h);
            current.battle = true;
        }
        
        characters_inbattle=0;
        for(k=0;k&lt;instance_number(BattleParent);k++)
        {
            if(instance_find(BattleParent,k).battle == true &amp;&amp; instance_find(BattleParent,k).dead == 0) characters_inbattle++;
        }
        battlequeue[characters_inbattle]=0;
        
        for(i=0;i&lt;characters_inbattle;i++)
        {
            maxinitiative=0;
            for(j=0;j&lt;characters_inbattle;j++)
            {
                current=instance_find(BattleParent,j);
                
                if(current.dead == 0 &amp;&amp; current.battle==true &amp;&amp; current.initiative&gt;maxinitiative &amp;&amp; current.myturn==-1)
                {
                    maxid=current.id;
                    maxinitiative=current.initiative;
                }
            }
            battlequeue[i]=maxid;
            maxid.myturn=i;
        }
        
        firstturn=false;
    }
    
    enemies_inbattle=0;
    for(k=0;k&lt;instance_number(Enemy);k++)
    {
        if(instance_find(Enemy,k).battle==true &amp;&amp; instance_find(Enemy,k).hp&gt;0) enemies_inbattle++;
    }
    
    heroes_inbattle=0;
    for(h=0;h&lt;instance_number(Hero);h++)
        {
            current = instance_find(Hero,h);
            if(current.hp &gt; 0) heroes_inbattle++;
        }
    
    if(nextturn)
    {
        actionid = 0;
        (currentChar).ap = (currentChar).maxap;
        with(Hex) pathMoveMark = false;
        turn++;
        if(turn&gt;=characters_inbattle) turn=0;
        
        for(i = 0; i &lt; 8; i++)
        {
            if((currentChar).buff[i, 0] == 1)
            {
                if((currentChar).buff[i, 1] &lt;= ((currentChar).maxhp - (currentChar).hp)) (currentChar).hp += (currentChar).buff[i, 1];
                else (currentChar).hp = (currentChar).maxhp;
            }
            if((currentChar).buff[i, 0]) (currentChar).buff[i, 2] -= 1;
        }
        
        for(i = 0; i &lt; 8; i++)
        {
            switch((currentChar).debuff[i, 0])
            {
                case 1:
                    (currentChar).hp -= (currentChar).debuff[i, 1];
                    break;
                case 2:
                    (currentChar).hp -= (currentChar).debuff[i, 1];
                    break;
                case 3:
                    (currentChar).hp -= (currentChar).debuff[i, 1];
                    break;
                case 4:
                    (currentChar).ap = 0;
                    break;
                case 5:
                    (currentChar).ap *= 0.8;
                    break;
            }
            if((currentChar).debuff[i, 0]) (currentChar).debuff[i, 2] -= 1;
        }
        
        if(heroesturn)
        {
            switch(InvCtrl.current_eq)
            {
                case 0:
                    for(i = 0; i &lt; 10; i++)
                    {
                        if(cooldown[0, i] &gt; 0) cooldown[0, i] --;
                    }
                    break;
                case 1:
                    for(i = 0; i &lt; 10; i++)
                    {
                        if(cooldown[1, i] &gt; 0) cooldown[1, i] --;
                    }
                    break;
                case 2:
                    for(i = 0; i &lt; 10; i++)
                    {
                        if(cooldown[2, i] &gt; 0) cooldown[2, i] --;
                    }
                    break;
                case 3:
                    for(i = 0; i &lt; 10; i++)
                    {
                        if(cooldown[3, i] &gt; 0) cooldown[3, i] --;
                    }
                    break;
            }
        }
        else
        {
            for(i = 0; i &lt; 3; i++)
            {
                if((currentChar).action[i, 5] &gt; 0) (currentChar).action[i, 5] --;
            }
        }
        
        nextturn = false;
    }
    
    if(keyboard_check_pressed(ord('1')))
    {
        if(cooldown[InvCtrl.current_eq, 0] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 0];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('2')))
    {
        if(cooldown[InvCtrl.current_eq, 1] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 1];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('3')))
    {
        if(cooldown[InvCtrl.current_eq, 2] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 2];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('4')))
    {
        if(cooldown[InvCtrl.current_eq, 3] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 3];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('5')))
    {
        if(cooldown[InvCtrl.current_eq, 4] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 4];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('6')))
    {
        if(cooldown[InvCtrl.current_eq, 5] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 5];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('7')))
    {
        if(cooldown[InvCtrl.current_eq, 6] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 6];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('8')))
    {
        if(cooldown[InvCtrl.current_eq, 7] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 7];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('9')))
    {
        if(cooldown[InvCtrl.current_eq, 8] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 8];
            marker = 0;
        }
    }
    if(keyboard_check_pressed(ord('0')))
    {
        if(cooldown[InvCtrl.current_eq, 9] == 0)
        {
            with(Hex) pathMoveMark = false;
            actionid = InvCtrl.action[InvCtrl.current_eq, 9];
            marker = 0;
        }
    }
    if(mouse_check_button_pressed(mb_right))
    {
        actionid = 0;
    }
    
    for(c=0;c&lt;instance_number(BattleParent);c++)
    {
        current = instance_find(BattleParent,c);
        current.marked = false;
    }
    
    if(onHud==false)
    {
        if(actionid == 0)
        {
            MarkerMask.scale = 0;
            
            if(mouse_check_button_pressed(mb_left) &amp;&amp; onHud==false &amp;&amp; marker!=0)
            {
                h = instance_position(marker.x, marker.y, Hex);
                if(!h.occupied)
                {
                    if(!instance_exists(MoveMarker) &amp;&amp; apcost&lt;=(currentChar).ap &amp;&amp; actionid==0)
                    {
                        instance_create(marker.x,marker.y,MoveMarker);
                        (currentChar).ap -= apcost;
                    }
                }
            }
        }
        
        else
        {
            MarkerMask.x = marker.x;
            MarkerMask.y = marker.y;
            MarkerMask.sprite_index = ActionCtrl.action[actionid, 3]
            MarkerMask.image_index = round((point_direction((currentChar).x,(currentChar).y,marker.x,marker.y))/60);
            if(mouse_check_button_pressed(mb_left) &amp;&amp; onHud==false &amp;&amp; marker!=0 &amp;&amp; ActionCtrl.action[actionid, 2] &lt;= (currentChar).ap)
            {
                instance_create(MarkerMask.x,MarkerMask.y,HitMarker);
                
                cooldown[InvCtrl.current_eq, actionid] = ActionCtrl.action[actionid, 8];
                
                (currentChar).ap -= ActionCtrl.action[actionid, 2];
                
                switch((currentChar).eq[0, 1])
                {
                    case 1:
                        (currentChar).timeline_index = animAttack2h;
                        break;
                    case 2:
                        (currentChar).timeline_index = animAttack2h;
                        break;
                    case 3:
                        (currentChar).timeline_index = animAttackMh;
                        break;
                    case 4:
                        (currentChar).timeline_index = animAttackMh;
                        break;
                    case 5:
                        (currentChar).timeline_index = animAttackMh;
                        break;
                    case 6:
                        (currentChar).timeline_index = animAttackBow;
                        break;
                    case 7:
                        (currentChar).timeline_index = animAttackCrossbow;
                        break;
                    case 8:
                        (currentChar).timeline_index = animAttackPistolMh;
                        break;
                    case 9:
                        (currentChar).timeline_index = animAttackGlavia;
                        break;
                }
                
                (currentChar).timeline_position = 0;
                (currentChar).timeline_speed = 1;
                (currentChar).timeline_loop = false;
                (currentChar).timeline_running = true;
            }
        }
    }
    
    if(heroes_inbattle&lt;=0 || enemies_inbattle&lt;=0)
    {
        with(Hex) instance_destroy();
        mode=0;
        firstturn=true;
    }
}
else
{
    with(DirWheel) instance_destroy();
}

if(overcast &lt; overcastfinal) overcast += 0.01;
if(overcast &gt; overcastfinal) overcast -= 0.01;

ctrl_frame = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*draw_set_color(c_black);
draw_set_alpha(0.5);
draw_rectangle(0,0,128,64,false);
draw_set_alpha(1);
draw_set_color(c_white);
draw_text(4,24,"FPS: " + string(showfps));
draw_text(4,36,"CPU: " + string(cpu_usage()));
draw_text(4,48,"RAM: " + string(ram_application()/1024/1024));

draw_text(4,60,"Time: " + string_format(hour, 2, 0) + ":" + string_format(minute, 2, 0));
*/
if(mode==1)
{
    for(q=0;q&lt;characters_inbattle;q++)
    {
        draw_set_colour($3f3f3f);
        draw_rectangle(view_wview/2-(64*characters_inbattle/2)+q*64,0,view_wview/2-(64*characters_inbattle/2)+(q+1)*64,64,false);
        portrait = battlequeue[q];
        draw_sprite_part_ext((portrait).sprite_index,(portrait).image_index,0,16,64,64,view_wview/2-(64*characters_inbattle/2)+q*64,0,1,1,image_blend,1);
        draw_set_colour($999999);
        draw_rectangle(view_wview/2-(64*characters_inbattle/2)+q*64,0,view_wview/2-(64*characters_inbattle/2)+(q+1)*64,64,true);
        if(turn!=q)
        {
            draw_set_alpha(0.3);
            draw_rectangle_colour(view_wview/2-(64*characters_inbattle/2)+q*64,0,view_wview/2-(64*characters_inbattle/2)+(q+1)*64,64,c_black,c_black,c_black,c_black,false);
            draw_set_alpha(1);
        }
        if((portrait).dead != 0)
        {
            draw_set_alpha(0.5);
            draw_rectangle_colour(view_wview / 2 - (64 * characters_inbattle / 2) + q * 64, 0, view_wview / 2 - (64 * characters_inbattle / 2) + (q + 1) * 64, 64, c_black, c_black, c_black, c_black, false);
            draw_set_alpha(1);
        }
    }
    
    if(instance_exists(DirWheel))
    {
        for(i = 0; i &lt; 6; i++)
        {
            if(dirwheelmouseover[i]) draw_sprite(sprDirWheelOver, i, view_wview / 2, view_hview - 112);
            else draw_sprite(sprDirWheel, i, view_wview / 2, view_hview - 112);
        }
    }
    
    draw_sprite_ext(sprBar, 0, view_wview / 2 - 52, view_hview - 64, -1, 1, 0, c_white, 1);
    draw_sprite_part_ext(sprResourceBar, 0, 0, 0, 192 * ((currentChar).hp / (currentChar).maxhp), 64, view_wview / 2 - 52, view_hview - 128, -1, 1, c_white, 1);
    draw_set_halign(fa_right);
    draw_text_outline(view_wview / 2 - 60, view_hview - 96, string((currentChar).hp) + " / " + string((currentChar).maxhp), c_white, c_black);
    
    draw_sprite_ext(sprBar, 0, view_wview / 2 + 52, view_hview - 64, 1, 1, 0, c_white, 1);
    draw_sprite_part_ext(sprResourceBar, 1, 0, 0, 192 * ((currentChar).ap / (currentChar).maxap), 64, view_wview / 2 + 52, view_hview - 128, 1, 1, c_white, 1);
    draw_set_halign(fa_left);
    draw_text_outline(view_wview / 2 + 60, view_hview - 96, string((currentChar).ap) + " / " + string((currentChar).maxap), c_white, c_black);
}

draw_set_colour(c_black);
draw_rectangle(0, view_hview - 4, view_wview, view_hview, false);
draw_set_colour(c_yellow);
draw_rectangle(0, view_hview - 4, view_wview * (InvCtrl.xp / InvCtrl.xp_to_lvl), view_hview, false);
draw_set_colour(c_black);
draw_set_halign(fa_center);
draw_set_valign(fa_bottom);
draw_text_outline(view_wview / 2, view_hview, string(InvCtrl.xp) + " / " + string(InvCtrl.xp_to_lvl), c_white, c_black);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(mode==1)
{

    for(k=0;k&lt;instance_number(BattleParent);k++)
    {
        current = instance_find(BattleParent,k);
        if(current.battle==true)
        {
            if(current.myturn == turn) draw_sprite(sprIndicator,0,current.x,current.y-88+(8*sin(degtorad(i*2))));
            if(!current.dead)
            {
                draw_rectangle_colour(current.x-27,current.y-current.height-4,current.x+27,current.y-current.height+4,c_black,c_black,c_black,c_black,false);
                draw_rectangle_colour(current.x-25,current.y-current.height-2,current.x+25,current.y-current.height+2,c_red,c_red,c_red,c_red,false);
                if(current.hp &gt; 0)
                {
                    draw_rectangle_colour(current.x-25,current.y-current.height-2,current.x-25+(50*current.hp/current.maxhp),current.y-current.height+2,green,green,green,green,false);
                }
            }
        }
    }
    
    if(h1.myturn==turn || h2.myturn==turn || h3.myturn==turn || h4.myturn==turn)
    {
        heroesturn = true;
        if(h1.myturn==turn) hero = h1;
        else if(h2.myturn==turn) hero = h2;
        else if(h3.myturn==turn) hero = h3;
        else if(h4.myturn==turn) hero = h4;
    }
    else heroesturn = false;
    
    if(heroesturn)
    {
        if(actionid==0 &amp;&amp; !instance_exists(MoveMarker) &amp;&amp; marker!=0)
        {       
            //apcost = sqrt((hero.x-marker.x)*(hero.x-marker.x)+4*(hero.y-marker.y)*(hero.y-marker.y))/4;
            //apcost = round(apcost);
            //draw_set_color(make_colour_rgb(51,204,255));
            //draw_set_alpha(0.1);
            //draw_ellipse(hero.x-(hero.ap*(100/25)),hero.y-(hero.ap*(100/25)/2),hero.x+(hero.ap*(100/25)),hero.y+(hero.ap*(100/25)/2),false);
            //draw_set_alpha(1);
            //draw_ellipse(hero.x-(hero.ap*(100/25)),hero.y-(hero.ap*(100/25)/2),hero.x+(hero.ap*(100/25)),hero.y+(hero.ap*(100/25)/2),true);
            //draw_set_color(c_white);
            //if(collision_line(hero.x,hero.y,marker.x,marker.y,Tree,true,true)) draw_sprite_ext(sprMoveMarker,0,marker.x,marker.y,1,0.5,0,c_red,0.8);
            //else draw_sprite_ext(sprMoveMarker,0,marker.x,marker.y,1,0.5,0,image_blend,0.8);
            if(apcost &gt; hero.ap) draw_set_color(c_red);
            else draw_set_color(c_white);
            draw_text(marker.x+40,marker.y-20,string(apcost));
            draw_set_color(c_white);
            //for(n=32;n&lt;point_distance(hero.x,hero.y,marker.x,marker.y)-64;n+=64)
            //{
                //draw_sprite_ext(sprMoveMarker,1,hero.x+lengthdir_x(n+dotdist,point_direction(hero.x,hero.y,marker.x,marker.y)),hero.y+(lengthdir_y(n+dotdist,point_direction(hero.x,hero.y,marker.x,marker.y))),1,0.5,0,image_blend,0.8);
            //}
        }
        
        else
        {
            //if(ActionCtrl.action[actionid,1]&gt;0) draw_set_colour(c_red);
            //else draw_set_colour(green);
            //apcost = ActionCtrl.action[actionid,2];
            //draw_text(mouse_x+40,mouse_y-20,string(apcost));
            
            draw_set_colour(c_white);
            //draw_sprite_ext(sprMoveMarker,0,mouse_x,mouse_y,1,0.5,0,c_red,0.8);
            
        }
    }
    
    onHud = false;
    
    if(mouse_y&gt;=view_yview &amp;&amp; mouse_y&lt;=view_yview+64)
    {
        for(q=0;q&lt;characters_inbattle;q++)
        {
            portrait = battlequeue[q];
            if(mouse_x&gt;=view_xview+view_wview/2-(64*characters_inbattle/2)+q*64 &amp;&amp; mouse_x&lt;=view_xview+view_wview/2-(64*characters_inbattle/2)+(q+1)*64)
            {
                d3d_set_fog(true,c_white,0,0);
                draw_sprite_ext((portrait).sprite_index,0,(portrait).x,(portrait).y,1,1,0,image_blend,0.5);
                d3d_set_fog(false,c_white,0,0);
                
                draw_set_halign(fa_center);
                draw_set_color(c_black);
                draw_text(view_xview+view_wview/2-1,view_yview+79,"Placeholder");
                draw_text(view_xview+view_wview/2+1,view_yview+79,"Placeholder");
                draw_text(view_xview+view_wview/2-1,view_yview+81,"Placeholder");
                draw_text(view_xview+view_wview/2+1,view_yview+81,"Placeholder");
                draw_set_color(c_white);
                draw_text(view_xview+view_wview/2,view_yview+80,"Placeholder");
                draw_set_halign(fa_left);
                
                onHud = true;
            }
        }
    }
    
    /*for(c=0;c&lt;instance_number(BattleParent);c++)
    {
    current = instance_find(BattleParent,c);
    if(current.battle == true)
        { 
        draw_text(current.x,current.y+8,string(sqrt(((currentChar).x-current.x)*((currentChar).x-current.x)+(((currentChar).y-current.y)*((currentChar).y-current.y)*4))));
        draw_text(current.x,current.y+20,string(angle_difference(point_direction((currentChar).x,(currentChar).y,mouse_x,mouse_y+(mouse_y-(currentChar).y)),point_direction((currentChar).x,(currentChar).y,current.x,current.y+(current.y-(currentChar).y)))));
        }
    }*/   
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="9" enumb="80">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>grass_density++;
if(grass_density&gt;5) grass_density=0;
with(GrassDrawer)
{
    check_grass = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="79">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(smoothing)
{
    texture_set_interpolation(false);
    smoothing = false;
}
else
{
    texture_set_interpolation(true);
    smoothing = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>grass_sway = !grass_sway;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="70">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>overcastfinal += 0.1;
if(overcastfinal &gt; 1) overcastfinal = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>(currentChar).ap = 100;
nextturn = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
